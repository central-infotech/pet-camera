# E2E テスト仕様書 — マルチメディア操作の同時実行

## 概要

スマホ側の「話す」「顔を見せる」「聞く」を様々な順序・組み合わせで操作した際に、
PC 側の画面（メインUI `/` および display ページ `/display`）が正常に動作し続けることを検証する。

また、デバイス単位の排他セッション制御（1台のスマホが機能使用中は他のスマホをブロック）
が正しく動作することを検証する。

## テスト環境

| 項目 | 内容 |
|------|------|
| スマホA (操作側) | スマホブラウザ（Chrome / Safari）からメインUI `/` にアクセス |
| スマホB (排他検証用) | 別のスマホブラウザから `/` にアクセス（異なる Tailscale IP） |
| PC 表示側 | PC ブラウザから `/display` にアクセス（飼い主映像の受信表示用） |
| PC メインUI | PC ブラウザから `/` にアクセス（カメラ映像・ステータス確認用） |
| ネットワーク | Tailscale VPN 経由（各デバイスに固有の 100.x.x.x IP） |

## 用語定義

| ボタン | 機能 | 動作方式 | 技術的な処理 |
|--------|------|----------|--------------|
| **聞く** | PC マイクの音をスマホで聞く | トグル（ON/OFF） | `audio_listen_start/stop` → サーバーが PCM を配信 |
| **話す** | スマホマイクで PC スピーカーに話す | 押し続け（Push-to-talk） | `getUserMedia(audio)` → `audio_talk` で PCM 送信 |
| **顔を見せる** | スマホカメラ映像+音声を PC に送る | トグル（ON/OFF） | `getUserMedia(video+audio)` → JPEG フレーム + 連続音声送信 |

### 重要な仕様

- **同一スマホ**: 「聞く」「話す」「顔を見せる」を**同時に利用可能**
- **排他制御**: 1台のスマホがいずれかの機能を使用中は、他のスマホからは全機能が**ブロック**される
- **排他の識別**: Tailscale VPN の IP アドレスでデバイスを識別する
- **排他の通知**: ブロックされたスマホには「他のデバイスが操作中のため、操作できません」バナーが表示され、3ボタンすべてが disabled になる
- **排他の解放**: 排他保持スマホの全機能が停止した時点で自動解放される

---

## 判定基準（全テスト共通）

各テストケースの「期待結果」に加え、以下を**常時確認**する:

| チェック項目 | 合格基準 |
|-------------|---------|
| PC メインUI (`/`) のカメラ映像 | MJPEG ストリームがフリーズしない（映像が更新され続ける） |
| PC display (`/display`) の表示 | 「顔を見せる」中はフレームが更新される / 停止後は「映像待機中」表示 |
| スマホ UI の応答性 | ボタン操作が即座に反映される（1秒以内） |
| ブラウザコンソール | 想定外のエラー（赤色）が出ていない |
| サーバーログ | `ERROR` レベルのログが出ていない |
| CPU / メモリ | PC ブラウザのメモリが際限なく増加しない |

---

## テストカテゴリ一覧

| カテゴリ | テスト数 | 内容 |
|---------|---------|------|
| A. 単機能の基本動作 | 6 | 各機能単独の ON/OFF |
| B. 同一スマホでの同時操作 | 9 | 同一スマホで2〜3機能を同時に利用 |
| C. 状態遷移の高速操作 | 4 | 連打・高速トグルでの安定性 |
| D. 排他セッション制御 | 9 | 複数スマホ間の排他検証 + 回帰テスト |
| E. 画面の非アクティブ | 5 | バックグラウンド遷移・復帰 |
| F. ネットワーク断・復帰 | 3 | 接続断後の回復 |
| G. PC Display 側の安定性 | 4 | display ページ固有のテスト |

---

## A. 単機能の基本動作

### A-1: 聞く — ON/OFF

**前提**: 全機能 OFF の状態
**操作**:
1. 「聞く」を ON にする
2. 5 秒待つ
3. 「聞く」を OFF にする

**期待結果**:
- ON 時: ボタンが active 表示になる。PC 側の音がスマホから聞こえる
- OFF 時: ボタンが非 active に戻る。音声が止まる
- PC メインUI の映像は影響を受けない

---

### A-2: 話す — 押し続け・離す

**前提**: 全機能 OFF の状態
**操作**:
1. 「話す」を押し続ける（3秒間）
2. 離す

**期待結果**:
- 押している間: ボタンが active 表示。PC スピーカーからスマホの音が出る
- 離した後: ボタンが非 active に戻る。音が止まる
- PC メインUI の映像は影響を受けない

---

### A-3: 話す — 短い押下の繰り返し

**前提**: 全機能 OFF の状態
**操作**:
1. 「話す」を短く押して離す（0.5 秒間）
2. 1 秒後にもう一度短く押して離す
3. 計 5 回繰り返す

**期待結果**:
- 毎回、押下→離す がクリーンに処理される
- サーバーログに `talk started` / `talk stopped` が対になって記録される
- PC メインUI の映像は影響を受けない

---

### A-4: 顔を見せる — ON/OFF

**前提**: 全機能 OFF の状態。PC で `/display` を開いておく
**操作**:
1. 「顔を見せる」を ON にする
2. 5 秒待つ
3. 「顔を見せる」を OFF にする

**期待結果**:
- ON 時:
  - カメラ許可ダイアログが出る（初回）
  - ボタンが active 表示。スマホに PiP プレビューが表示される
  - **「聞く」「話す」ボタンは disabled にならない（有効のまま）**
  - PC display に映像が表示される
  - ステータスに「送信中: 640x480 / 10fps」が表示される
- OFF 時:
  - ボタンが非 active に戻る。PiP プレビューが消える
  - PC display に「映像待機中」が表示される

---

### A-5: 顔を見せる — PC Display 未接続時

**前提**: PC で `/display` を開いて**いない**
**操作**:
1. 「顔を見せる」を ON にする
2. 5 秒待つ
3. OFF にする

**期待結果**:
- スマホ側は正常に送信状態になる（ステータス「接続PC: 0台」）
- エラーは発生しない
- OFF 時にクリーンに停止する

---

### A-6: 聞く — ON のまま放置（長時間安定性）

**前提**: 全機能 OFF の状態
**操作**:
1. 「聞く」を ON にする
2. 3 分間放置する
3. OFF にする

**期待結果**:
- 3 分間、音声が途切れず配信される
- メモリ使用量が安定している（ブラウザの DevTools で確認）
- OFF 時にクリーンに停止する

---

## B. 同一スマホでの同時操作

### B-1: 聞く ON → 話す（聞きながら話す）

**前提**: 全機能 OFF
**操作**:
1. 「聞く」を ON にする
2. 「話す」を押し続ける（3秒間）
3. 「話す」を離す
4. 「聞く」が引き続き ON であることを確認
5. 「聞く」を OFF にする

**期待結果**:
- 「聞く」ON 中に「話す」が正常に機能する
- 「話す」を離しても「聞く」の状態は変わらない
- PC メインUI の映像は影響を受けない

---

### B-2: 話す中 → 聞く ON/OFF

**前提**: 全機能 OFF
**操作**:
1. 「話す」を押し続ける
2. 押したまま「聞く」を ON にする
3. 押したまま「聞く」を OFF にする
4. 「話す」を離す

**期待結果**:
- 「話す」を押している間ずっと音声が送信される
- 「聞く」の ON/OFF が「話す」に影響しない
- 全操作後、すべての状態がクリーンにリセットされる

---

### B-3: 聞く ON → 顔を見せる ON（聞きながら顔を見せる）

**前提**: 全機能 OFF。PC で `/display` を開いておく
**操作**:
1. 「聞く」を ON にする
2. 「顔を見せる」を ON にする
3. 5 秒待つ
4. 「顔を見せる」を OFF にする
5. 「聞く」ボタンの状態を確認する

**期待結果**:
- 手順 2: **「聞く」は ON のまま継続される**（ハウリング防止の自動停止はない）
- 手順 3: PC display に映像が正常に表示される。音声が PC スピーカーから出る。同時に PC のマイク音もスマホで聞こえる
- 手順 4: 映像送信が停止する。連続音声送信が停止する
- 手順 5: **「聞く」は ON のまま**（影響を受けない）
- PC メインUI の映像は全操作を通じてフリーズしない

---

### B-4: 顔を見せる ON 中に聞く ON/OFF

**前提**: 「顔を見せる」が ON の状態。PC で `/display` に映像表示中
**操作**:
1. 「聞く」を ON にする
2. 5 秒待つ
3. 「聞く」を OFF にする

**期待結果**:
- 手順 1: 「聞く」が正常に開始される（ボタンは disabled ではない）
- 手順 2: PC のマイク音がスマホで聞こえる。映像送信も継続している
- 手順 3: 音声受信が停止する。映像送信は継続している

---

### B-5: 顔を見せる ON 中に話す

**前提**: 「顔を見せる」が ON の状態（連続音声送信中）
**操作**:
1. 「話す」を押し続ける（3秒間）
2. 「話す」を離す

**期待結果**:
- 「話す」ボタンは disabled ではなく操作可能
- 押している間、ボタンが active 表示になる（連続音声が既に送信中のため実質的に追加の処理はない）
- 離した後、ボタンが非 active に戻る
- **連続音声送信が中断されない**（`stopTalking()` が `isContinuousTalking` ガードで早期リターンする）

---

### B-6: 顔を見せる ON → OFF → 聞く ON

**前提**: 全機能 OFF。PC で `/display` を開いておく
**操作**:
1. 「顔を見せる」を ON にする
2. 3 秒待つ
3. 「顔を見せる」を OFF にする
4. 「聞く」を ON にする
5. 3 秒待つ
6. 「聞く」を OFF にする

**期待結果**:
- 手順 4: 排他が解放されており（全機能停止済み）、「聞く」が正常に開始される
- 手順 5: PC の音がスマホから聞こえる
- PC メインUI と display が全操作を通じて正常

---

### B-7: 顔を見せる ON → OFF → 話す

**前提**: 全機能 OFF
**操作**:
1. 「顔を見せる」を ON にする
2. 3 秒待つ
3. 「顔を見せる」を OFF にする
4. 「話す」を押し続ける（3秒間）
5. 「話す」を離す

**期待結果**:
- 手順 4: push-to-talk が正常に機能する（`acquire_talk()` が成功する）
- サーバーログに `talk started` / `talk stopped` が正常に記録される

---

### B-8: 3機能すべて同時（聞く + 顔を見せる + 話す ボタン押下）

**前提**: 全機能 OFF。PC で `/display` を開いておく
**操作**:
1. 「聞く」を ON にする
2. 「顔を見せる」を ON にする
3. 「話す」を押し続ける（3秒間）
4. 「話す」を離す
5. 3 秒待つ
6. 「顔を見せる」を OFF にする
7. 「聞く」を OFF にする

**期待結果**:
- 手順 2: 映像送信開始。聞くは ON のまま
- 手順 3: 連続音声が既に送信中なので push-to-talk は実質 no-op。エラーなし
- 手順 5: 映像 + 連続音声 + リスニングが同時に正常動作
- 手順 6: 映像・連続音声停止。聞くは ON のまま
- 手順 7: 聞く停止。全機能 OFF
- **全操作を通じて PC メインUI のカメラ映像がフリーズしない**
- **PC display が手順 2-6 で映像を正常に表示する**

---

### B-9: 全機能を使った操作シーケンス（統合テスト）

**前提**: 全機能 OFF。PC で `/display` を開いておく
**操作**:
1. 「聞く」を ON にする
2. 3 秒待つ
3. 「話す」を押し続ける（2秒）→ 離す
4. 「顔を見せる」を ON にする
5. 5 秒待つ（PC display で映像確認。聞くも継続していることを確認）
6. 「聞く」を OFF にする
7. 3 秒待つ
8. 「聞く」を ON にする
9. 3 秒待つ
10. 「顔を見せる」を OFF にする
11. 「話す」を押し続ける（2秒）→ 離す
12. 「聞く」を OFF にする

**期待結果**:
- 全 12 ステップを通じてスマホ UI が正常に応答する
- PC メインUI のカメラ映像が全ステップを通じてフリーズしない
- PC display が手順 4-10 で映像を表示する
- 最終状態: 全機能 OFF、全ボタン有効

---

## C. 状態遷移の高速操作

### C-1: 聞く の高速トグル

**前提**: 全機能 OFF
**操作**:
1. 「聞く」を 1 秒間隔で ON→OFF→ON→OFF を **10 回**繰り返す

**期待結果**:
- 操作後の最終状態が UI とサーバー側で一致している
- サーバーの `_audio_listeners` にゴミが残っていない（`/api/status` の `audio.listening_clients` が 0 または 1）
- PC メインUI の映像が影響を受けない

---

### C-2: 顔を見せる の高速トグル

**前提**: 全機能 OFF。PC で `/display` を開いておく
**操作**:
1. 「顔を見せる」を ON にする
2. 2 秒後に OFF にする
3. 1 秒後に ON にする
4. 2 秒後に OFF にする
5. 手順 3-4 を**さらに 3 回**繰り返す（計 5 回の ON/OFF）

**期待結果**:
- 毎回 `_active_sender_sid` が正しくセット・リリースされる
- 排他が毎回正しく取得・解放される
- PC display がフリーズしない
- スマホの MediaStream トラックが毎回正しく停止・再取得される
- メモリリークがない（Blob URL が毎回 revoke される）

---

### C-3: 話す の連打

**前提**: 全機能 OFF
**操作**:
1. 「話す」を 0.3 秒間隔で押下→離すを **20 回**繰り返す

**期待結果**:
- サーバー側の `_talking_clients` が操作完了後に 0 に戻る
- `getUserMedia` の取得・解放が毎回正しく行われる
- コンソールにエラーが出ない

---

### C-4: 顔を見せる ON → 即 OFF（超短時間）

**前提**: 全機能 OFF
**操作**:
1. 「顔を見せる」を ON にする
2. **即座に**（1秒以内）OFF にする

**期待結果**:
- `getUserMedia` → カメラ取得 → Socket 接続 → 停止処理が競合しない
- サーバー側の状態がクリーンにリセットされる（排他も解放される）
- 全ボタンが有効な状態に戻る

---

## D. 排他セッション制御

### D-1: スマホA 聞く ON → スマホB 全機能ブロック

**前提**: スマホA、スマホBともに全機能 OFF。両方ともページを開いている
**操作**:
1. スマホA で「聞く」を ON にする
2. スマホB の画面を確認する
3. スマホB で「聞く」ボタンを押してみる

**期待結果**:
- 手順 2: スマホB に「他のデバイスが操作中のため、操作できません」バナーが表示される
- 手順 2: スマホB の「聞く」「話す」「顔を見せる」ボタンがすべて disabled になる
- 手順 3: ボタンが押せない（disabled）

---

### D-2: スマホA 機能停止 → スマホB ブロック解除

**前提**: スマホA が「聞く」ON の状態。スマホB はブロック中
**操作**:
1. スマホA で「聞く」を OFF にする
2. スマホB の画面を確認する
3. スマホB で「聞く」を ON にする

**期待結果**:
- 手順 2: スマホB のバナーが消える。全ボタンが有効になる
- 手順 3: スマホB で「聞く」が正常に動作する
- スマホA のバナーが表示される（スマホB が排他を取得したため）

---

### D-3: スマホA 顔を見せる ON → スマホB ブロック → スマホA OFF → スマホB 解除

**前提**: スマホA、スマホBともに全機能 OFF。PC で `/display` を開いておく
**操作**:
1. スマホA で「顔を見せる」を ON にする
2. スマホB の画面を確認する（ブロックされていること）
3. スマホA で「顔を見せる」を OFF にする
4. スマホB の画面を確認する（ブロック解除されていること）
5. スマホB で「顔を見せる」を ON にする
6. PC display で映像確認
7. スマホB で「顔を見せる」を OFF にする

**期待結果**:
- 手順 2: スマホB がブロック（バナー表示、全ボタン disabled）
- 手順 4: スマホB のブロックが解除される
- 手順 5-6: スマホB の映像が PC display に表示される
- 手順 7: 全スマホがブロック解除状態

---

### D-4: スマホA 複数機能使用中 → 一部停止 → 排他継続

**前提**: スマホA、スマホBともに全機能 OFF
**操作**:
1. スマホA で「聞く」を ON にする
2. スマホA で「顔を見せる」を ON にする
3. スマホB がブロック中であることを確認
4. スマホA で「聞く」を OFF にする
5. スマホB がまだブロック中であることを確認
6. スマホA で「顔を見せる」を OFF にする
7. スマホB のブロックが解除されることを確認

**期待結果**:
- 手順 4: 「聞く」を停止しても「顔を見せる」がアクティブなため排他は継続
- 手順 5: スマホB は引き続きブロック中
- 手順 6: スマホA の全機能が停止したため排他が解放される
- 手順 7: スマホB が操作可能になる

---

### D-5: スマホA 切断 → 排他自動解放

**前提**: スマホA が「聞く」ON の状態。スマホB はブロック中
**操作**:
1. スマホA のブラウザを閉じる（またはページを離脱する）
2. スマホB の画面を確認する（少し待つ。Socket.IO の切断検知に数秒かかる場合がある）

**期待結果**:
- スマホA の切断が検知された後、排他が自動解放される
- スマホB のブロックが解除される（バナー消失、ボタン有効化）

---

### D-6: スマホA 操作中 → スマホB がページを開く（後から接続）

**前提**: スマホA が「聞く」ON の状態
**操作**:
1. スマホB でページを開く（初めてアクセス、またはリロード）

**期待結果**:
- スマホB のページ読み込み直後にブロック状態が表示される
- `audio_connect` 時にサーバーから `exclusive_status: {blocked: true}` が送信される
- バナーが表示され、ボタンが disabled になる

---

### D-7: 排他中にスマホA がページリロード

**前提**: スマホA が「聞く」ON の状態。スマホB はブロック中
**操作**:
1. スマホA でページをリロードする
2. スマホB の画面を確認する
3. スマホA で「聞く」を ON にする
4. スマホB の画面を確認する

**期待結果**:
- 手順 1: リロードにより旧接続が切断 → 排他が解放される
- 手順 2: スマホB のブロックが解除される
- 手順 3: スマホA が再度排他を取得
- 手順 4: スマホB が再びブロックされる

---

### D-8: トーカーA + リスナーB切断 → Cが送話開始（トークスロット回帰テスト）

**前提**: スマホA、スマホB、スマホC の 3 台を用意。スマホA は排他を保持していない状態
**操作**:
1. スマホA で「話す」を押し続ける（トークスロットを取得）
2. スマホB で「聞く」を ON にする（同一 IP のため許可される — ※同じ IP でない場合はスマホA で「聞く」ON にする）
3. リスナー側のブラウザを閉じる（切断する）
4. スマホA で「話す」を離す
5. スマホC で「話す」を押し続ける

**期待結果**:
- 手順 3: リスナーの切断によって**トークスロットが誤解放されない**（`release_talk()` は `_talking_sid` と一致する SID のみ実行）
- 手順 3: スマホA が引き続き話せている
- 手順 4: スマホA がトークスロットを正常に解放
- 手順 5: スマホC がトークスロットを正常に取得できる

> **注**: このテストは `audio_disconnect` で非トーカーの切断がトークスロットに影響しないことを検証する回帰テスト

---

### D-9: 排他ブロック中にスマホB が audio_talk を直接送信（認可バイパステスト）

**前提**: スマホA が「話す」を使用中（トークスロットを保持）
**操作**:
1. スマホB のブラウザコンソールから、Socket.IO で直接 `audio_talk` イベントにバイナリデータを送信する

**期待結果**:
- サーバーが `request.sid != _talking_sid` を検証し、データを破棄する
- PC スピーカーからスマホB の音声は出ない
- スマホA の送話には影響がない

---

## E. 画面の非アクティブ（Visibility Change）

### E-1: 聞く ON 中にバックグラウンドへ → 復帰

**前提**: 「聞く」が ON の状態
**操作**:
1. スマホのホームボタンを押す（またはアプリ切り替え）でブラウザをバックグラウンドにする
2. 10 秒待つ
3. ブラウザに戻る

**期待結果**:
- 復帰後、AudioContext が resume される
- Socket.IO が再接続される（切断していた場合）
- 「聞く」が自動復帰する（`_wasListening` フラグによるリカバリ）
- 音声が再び聞こえる

---

### E-2: 顔を見せる ON 中にバックグラウンドへ → 復帰

**前提**: 「顔を見せる」が ON の状態。PC で `/display` に映像表示中
**操作**:
1. スマホをバックグラウンドにする
2. 10 秒待つ
3. スマホに戻る

**期待結果**:
- バックグラウンド中: 映像フレーム送信が停止する（OS による制約）
- 復帰後: video socket が再接続を試みる
- MediaStream のトラックが `ended` の場合:
  - ステータスに「カメラが停止しました。再度「顔を見せる」を押してください。」が表示される
- MediaStream のトラックが `live` の場合:
  - フレーム送信が自動再開される
- PC display がフリーズしない（映像停止中は「映像が途切れました」表示）

---

### E-3: 顔を見せる + 聞く ON 中にバックグラウンドへ → 復帰

**前提**: 「顔を見せる」と「聞く」が両方 ON の状態
**操作**:
1. スマホをバックグラウンドにする
2. 10 秒待つ
3. スマホに戻る
4. 「顔を見せる」を OFF にする
5. 「聞く」の状態を確認する

**期待結果**:
- 手順 3: Socket.IO 再接続。映像送信は再開 or 再操作を促す
- 手順 4: 停止処理が正常に完了する
- 手順 5: 「聞く」がリカバリされて ON のままである（`_wasListening` による自動復帰）
- 排他がクリーンに管理されている

---

### E-4: PC Display をバックグラウンドにする → 復帰

**前提**: 「顔を見せる」が ON で、PC display に映像が表示されている
**操作**:
1. PC で display タブを非アクティブにする（別タブに切り替え）
2. 10 秒待つ
3. display タブに戻る

**期待結果**:
- タブ復帰後、Socket.IO が再接続される（切断していた場合）
- Wake Lock が再取得される
- 映像フレームの受信・表示が再開される
- メモリリークがない

---

### E-5: スマホの画面ロック → 復帰

**前提**: 「顔を見せる」が ON の状態
**操作**:
1. スマホの電源ボタンで画面をロックする
2. 30 秒待つ
3. 画面ロックを解除してブラウザに戻る

**期待結果**:
- 復帰後の動作が E-2 と同等
- MediaStream トラックの状態に応じて適切に回復またはユーザーに通知される

---

## F. ネットワーク断・復帰

### F-1: 聞く ON 中にネットワーク断 → 復帰

**前提**: 「聞く」が ON の状態
**操作**:
1. スマホの機内モードを ON にする（ネットワーク断）
2. 5 秒待つ
3. 機内モードを OFF にする（ネットワーク復帰）

**期待結果**:
- 復帰後、Socket.IO が自動再接続される
- `_wasListening` フラグにより「聞く」が自動復帰する
- 再接続後に音声が聞こえる
- PC メインUI は影響を受けない

---

### F-2: 顔を見せる ON 中にネットワーク断 → 復帰

**前提**: 「顔を見せる」が ON の状態。PC display に映像表示中
**操作**:
1. スマホの機内モードを ON にする
2. 10 秒待つ
3. 機内モードを OFF にする

**期待結果**:
- 切断中: PC display に「映像が途切れました」が表示される
- スマホのステータスに「再接続中...」が表示される
- 復帰後: video socket が再接続され、フレーム送信が再開される
- サーバー側: 切断時に `_active_sender_sid` がクリアされ、再接続時に再設定される
- PC display に映像が再び表示される

---

### F-3: 顔を見せる ON 中にネットワーク断 → 復帰 → OFF → 他機能

**前提**: 「顔を見せる」が ON の状態
**操作**:
1. スマホの機内モードを ON にする
2. 10 秒待つ
3. 機内モードを OFF にする
4. 再接続完了を待つ
5. 「顔を見せる」を OFF にする
6. 「聞く」を ON にする
7. 「話す」を押し続ける（2秒）→ 離す

**期待結果**:
- 手順 5: クリーンに停止する
- 手順 6-7: 正常に動作する（ネットワーク断・復帰の影響が残らない）

---

## G. PC Display 側の安定性

### G-1: 長時間の映像受信

**前提**: 「顔を見せる」が ON。PC display で映像受信中
**操作**:
1. 3 分間そのまま映像を受信し続ける

**期待結果**:
- 映像が途切れずに表示され続ける
- PC ブラウザのメモリ使用量が安定する（Blob URL が毎フレーム revoke されている）
- フレームレートが安定している（概ね 10fps）

---

### G-2: Display ページのリロード

**前提**: 「顔を見せる」が ON。PC display で映像受信中
**操作**:
1. PC display ページをリロードする（F5）
2. リロード完了を待つ

**期待結果**:
- リロード後、自動的に再接続される
- 映像が再び表示される
- サーバー側: 旧接続の `display_clients` がクリーンアップされ、新接続が追加される

---

### G-3: Display と メインUI の同時表示

**前提**: PC で `/display` と `/` を両方開いている。「顔を見せる」が ON
**操作**:
1. 両方のタブを確認する

**期待結果**:
- `/display`: 飼い主映像が表示される
- `/`: カメラ映像（MJPEG）が正常に表示される
- 両方が同時に正常動作する（互いに干渉しない）

---

### G-4: スマホ側の顔を見せる ON/OFF を Display で観測

**前提**: PC display を開いている
**操作**:
1. スマホで「顔を見せる」を ON にする
2. PC display で映像が表示されることを確認
3. スマホで「顔を見せる」を OFF にする
4. PC display が「映像待機中」になることを確認
5. 手順 1-4 を **5 回**繰り返す

**期待結果**:
- 毎回正常に映像表示 → 待機中の遷移が行われる
- PC display がフリーズしない
- 「映像が途切れました」→「映像待機中」の遷移が 3 秒以内（タイムアウト設定に依存）

---

## 既知のリスク・注意点

コード分析に基づく、テスト時に特に注目すべきポイント:

### 1. `startContinuousTalk()` と `startTalking()` の状態共有

`startContinuousTalk()` は `isTalking = true` を設定するため、「顔を見せる」中は
`startTalking()` が冒頭の `if (isTalking) return;` で早期リターンする。
`stopTalking()` も `if (isContinuousTalking) return;` ガードにより連続音声を中断しない。
ただし、手動トーク中に `startContinuousTalk()` が呼ばれた場合は旧プロセッサをクリーンアップし
トークスロットを引き継ぐ。

### 2. `release_talk()` の条件付き呼び出し

`audio_disconnect()` で、`_talking_sid == sid` の場合のみ `release_talk()` を呼ぶ。
これにより、トークしていないクライアントの切断がトークスロットに影響しない。
（テスト D-8 で回帰テストを実施）

### 3. `audio_talk` の SID 認可チェック

`audio_talk` ハンドラでは `request.sid == _talking_sid` を検証し、トークスロットを持たない
クライアントからの音声データを破棄する。これにより、排他制御を迂回した不正送話を防止する。
（テスト D-9 で検証）

### 4. `async_mode="threading"` での同期ブロック (注意点)

`async_mode="threading"` を使用。`audio_player.play()` 内の `_stream.write()` は
sounddevice のバッファが一杯だとブロックする可能性がある。
この間、同スレッドの他の Socket.IO イベント（video_frame のリレーなど）が遅延し、
**PC Display のフリーズ**の原因となり得る。

### 5. Display 側の Blob URL メモリ管理

毎フレーム `URL.revokeObjectURL` → `URL.createObjectURL` を行っているが、
ブラウザの GC が追いつかない場合にメモリ増大の可能性がある。
10fps x 30-50KB/frame = 約 300-500KB/秒 のオブジェクト生成。

### 6. 排他セッションの解放遅延

排他保持デバイスが強制終了（ブラウザクラッシュ等）した場合、Socket.IO の
ping/pong タイムアウト（デフォルト約 20-45 秒）まで排他が解放されない。
この間、他のスマホはブロックされ続ける。
