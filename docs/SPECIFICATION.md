# Pet Camera System — 仕様書

## 1. プロジェクト概要

外出時に自宅のペットの様子をリアルタイムで確認するためのシステム。
Windows PC の内蔵カメラ（またはUSBカメラ）を常時稼働させ、スマートフォンやタブレットから安全に映像・音声を双方向でやり取りできるようにする。

### 1.1 基本方針

- **ローカルファースト**: 映像・音声配信サーバーは自宅PCで稼働させる（クラウドに映像を送らない）
- **セキュリティ多層防御**: Tailscale VPN + アプリケーション認証トークンの二層構成
- **シンプル**: 最小限の構成で確実に動作することを重視する
- **無料運用**: すべて無料枠の範囲で運用する

---

## 2. システム構成

```
┌──────────────────────────────────────────────────────────┐
│  自宅 Windows PC                                          │
│                                                            │
│  ┌───────────┐    ┌─────────────────────────────────┐    │
│  │  Webカメラ  │───▶│                                 │    │
│  └───────────┘    │  ストリーミングサーバー            │    │
│  ┌───────────┐    │  (Python + OpenCV + Flask)        │    │
│  │  マイク    │───▶│  Port: 5555                      │    │
│  └───────────┘    │                                   │    │
│  ┌───────────┐    │  映像: MJPEG over HTTPS           │    │
│  │  スピーカー │◀───│  音声: WSS (WebSocket Secure)     │    │
│  └───────────┘    │                                   │    │
│                    │  ┌────────────┐ ┌──────────────┐ │    │
│                    │  │ Web UI     │ │ Auth Token   │ │    │
│                    │  │ (HTML/JS)  │ │ Middleware   │ │    │
│                    │  └────────────┘ └──────────────┘ │    │
│                    └─────────────────────────────────┘    │
│                              │                             │
│  ┌───────────────────────────┼───────────────────────┐   │
│  │  Tailscale (VPN)          │                        │   │
│  │  100.x.x.x               │                        │   │
│  └───────────────────────────┼───────────────────────┘   │
└──────────────────────────────┼────────────────────────────┘
                               │ Tailscale 暗号化トンネル
                ┌──────────────┼──────────────┐
                │              │              │
          ┌─────┴─────┐ ┌─────┴─────┐ ┌─────┴─────┐
          │ スマホ(夫) │ │ スマホ(妻) │ │ タブレット │
          │ Tailscale  │ │ Tailscale  │ │ Tailscale  │
          │ + ブラウザ │ │ + ブラウザ │ │ + ブラウザ │
          │ 🎤⇄🔊     │ │ 🎤⇄🔊     │ │ 🎤⇄🔊     │
          └───────────┘ └───────────┘ └───────────┘

          Phase 1 映像: PC → クライアント（MJPEG over HTTPS 単方向）
          Phase 1 音声: PC ⇄ クライアント（WSS 双方向）
```

### Phase 2 追加フロー: 飼い主表示モード

```
┌──────────────────────────────────────────────────────────┐
│  自宅 Windows PC（ケージ横に設置）                         │
│                                                            │
│  ┌─────────────────────┐                                  │
│  │  ブラウザ /display    │  ← フルスクリーン表示            │
│  │  ┌─────────────────┐ │                                  │
│  │  │ 飼い主の映像     │ │  ← スマホから受信した映像を描画   │
│  │  │ (JPEG → canvas)  │ │                                  │
│  │  └─────────────────┘ │                                  │
│  └─────────────────────┘                                  │
│  ┌───────────┐                                            │
│  │  スピーカー │ ◀── 飼い主の声を再生（既存 Talk 機能）     │
│  └───────────┘                                            │
│                                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │  ストリーミングサーバー (Flask + Flask-SocketIO)      │  │
│  │                                                      │  │
│  │  [/video namespace]                                  │  │
│  │  スマホ → video_frame → サーバー → video_frame → PC  │  │
│  │                                                      │  │
│  │  [/audio namespace] (既存)                           │  │
│  │  スマホ → audio_talk → サーバー → PC スピーカー      │  │
│  └────────────────────────────────────────────────────┘  │
│                                                            │
│  ┌───────────────────────────────────────────────────┐   │
│  │  Tailscale (VPN)                                    │   │
│  └───────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────┘
                               │ Tailscale 暗号化トンネル
                ┌──────────────┼──────────────┐
          ┌─────┴─────┐ ┌─────┴─────┐
          │ スマホ(夫) │ │ スマホ(妻) │
          │ Tailscale  │ │ Tailscale  │
          │ + ブラウザ │ │ + ブラウザ │
          │            │ │            │
          │ 📹 フロント │ │ 📹 フロント │  ← getUserMedia でフロントカメラ取得
          │ カメラ送信  │ │ カメラ送信  │  ← JPEG → Socket.IO でサーバーへ送信
          │ 🎤 マイク   │ │ 🎤 マイク   │  ← 既存 Talk 機能を常時 ON
          └───────────┘ └───────────┘

          Phase 2 映像: スマホ → サーバー → PC（Socket.IO 経由 JPEG リレー）
          Phase 2 音声: スマホ → サーバー → PC スピーカー（既存 Talk 機能の常時 ON）
```

---

## 3. 技術スタック

| レイヤー | 技術 | 選定理由 |
|---------|------|---------|
| カメラ制御 | OpenCV (Python) | Windows のカメラを安定して制御でき、実績が豊富 |
| 音声入出力 | sounddevice (Python) | PortAudio バイナリ同梱。ビルド不要で Windows に容易に導入可能 |
| Web サーバー | Flask (Python) | 軽量で MJPEG ストリーミングとの相性が良い |
| WebSocket | Flask-SocketIO (`manage_session=False`) | Flask との統合が容易。音声の双方向リアルタイム通信に使用。Flask 3.1+ との互換性のため `manage_session=False` で初期化 |
| 映像配信 | MJPEG over HTTPS | ブラウザ互換性が高く、実装がシンプル |
| 音声配信 | WSS (WebSocket Secure, binary) | 低遅延の双方向音声ストリーミング。HTTPS と統一しMixed Content を回避 |
| フロントエンド | HTML + CSS + JavaScript (Vanilla) | フレームワーク不要。Web Audio API / getUserMedia を使用 |
| VPN | Tailscale | 無料（個人利用）、セットアップが簡単、WireGuard ベースで高速 |
| プロセス管理 | NSSM (Windows サービス化) | 異常終了時の自動再起動・ログ管理に対応 |

### 3.1 外部サービスの活用

| サービス | 用途 |
|---------|------|
| GitHub | ソースコード管理 |

> **注意**: Phase 1・Phase 2 ともにクラウドサービスへのデプロイは不要。すべてローカルで完結する。

---

## 4. 機能一覧

### Phase 1 — MVP（最小実用製品）

| # | 機能 | 説明 |
|---|------|------|
| F-01 | ライブ映像配信 | MJPEG ストリームでリアルタイム映像を配信 |
| F-02 | Web ビューワー | ブラウザでライブ映像を表示するレスポンシブ UI |
| F-03 | スナップショット取得 | 現在の映像を静止画（JPEG）としてダウンロード。サーバーには保存しない |
| F-04 | スナップショット保存 | 明示的に保存操作を行うとサーバーに JPEG を保存。保存上限 500MB、FIFO で古いものから自動削除 |
| F-05 | カメラ設定調整 | 解像度・フレームレート・明るさ・コントラストを UI から変更可能 |
| F-06 | Tailscale VPN 接続 | VPN 経由でのみアクセスを許可 |
| F-07 | アプリケーション認証 | トークンベースの認証。初回アクセス時にトークン入力を要求 |
| F-08 | 自動起動・自動復旧 | NSSM による Windows サービス化。異常終了時は自動再起動 |
| F-09 | ステータス表示 | 接続状態・稼働時間・FPS をヘッダーに表示 |
| F-10 | アクセスログ | 全リクエストをファイルに記録（日時・IP・エンドポイント・ステータスコード） |
| F-11 | 音声リスニング（家→外） | PC のマイクで家の音声を拾い、クライアントのスピーカーで再生 |
| F-12 | 音声トーク（外→家） | クライアントのマイクで声を拾い、PC のスピーカーから再生してペットに声を届ける |
| F-13 | パスキー認証（WebAuthn） | 初回トークン認証後、デバイスの生体認証（指紋・顔認証）を登録し、次回以降パスキーでログイン可能にする |

### Phase 2 — 飼い主表示モード（スマホ → PC 逆方向ストリーミング）

ケージ横に置いた PC で飼い主の顔と声をペットに届ける機能。スマホのフロントカメラ映像をサーバー経由で PC ブラウザにリアルタイム表示し、音声は既存の Talk 機能を常時 ON にすることで実現する。

| # | 機能 | 説明 |
|---|------|------|
| F-14 | PC 表示画面 | `/display` ページ。スマホから送信された飼い主の映像をフルスクリーンで表示する。ケージ横の PC で開く |
| F-15 | スマホカメラ送信 | スマホのフロントカメラ映像を JPEG エンコードし、Socket.IO 経由でサーバーに送信する |
| F-16 | 映像リレー | サーバーがスマホから受信した JPEG フレームを PC 表示クライアントへリアルタイム中継する |
| F-17 | 常時トーク | 既存の Talk 機能（F-12）を常時 ON モードで動作させ、スマホのマイク音声を PC スピーカーから継続的に再生する |

### Phase 3 — PWA / UX 改善

| # | 機能 | 説明 |
|---|------|------|
| F-18 | PWA 対応 | Web App Manifest + Service Worker でホーム画面追加・スタンドアロン起動に対応。Android Chrome / iOS Safari 両対応 |
| F-19 | 画面更新ボタン | ヘッダー中央にアイコン付きの「画面更新」ボタンを配置。タップで `location.reload()` を実行 |

---

## 5. 画面設計

### 5.1 メイン画面（ビューワー）

```
┌─────────────────────────────────────────────────┐
│  🐾 Pet Camera    [↻ 画面更新]  ● LIVE 00:03:42 │  ← ヘッダー（中央に更新ボタン）
├─────────────────────────────────────────────────┤
│                                                   │
│            ┌──────────────────────┐               │
│            │                      │               │
│            │    ライブ映像         │               │  ← メイン映像エリア
│            │    (MJPEG)           │               │
│            │                      │               │
│            └──────────────────────┘               │
│                                                   │
├─────────────────────────────────────────────────┤
│  [🔊 聞く ON/OFF]  [🎤 話す (押している間)]       │  ← 音声コントロール
│  音量: [━━━●━━━]                                 │
├─────────────────────────────────────────────────┤
│  [📷 スナップショット]  [💾 保存]  [⚙ 設定]      │  ← コントロールバー
└─────────────────────────────────────────────────┘
```

### 5.2 音声操作の仕様

| ボタン | 動作 | 説明 |
|--------|------|------|
| 🔊 聞く | トグル（ON/OFF） | ON にすると家の音声がスマホから流れる |
| 🎤 話す | プッシュ・トゥ・トーク（押している間だけ） | ボタンを押している間、スマホのマイク音声がPCスピーカーから再生される |
| 音量スライダー | ドラッグ | 受信音声（家の音）の再生音量を調整 |

> **プッシュ・トゥ・トークの理由**: 常時双方向にするとハウリング（エコー）のリスクがあるため、話す側は明示的に操作する方式とする。

### 5.3 設定パネル（オーバーレイ）

```
┌──────────────────────────┐
│  カメラ設定          [×] │
├──────────────────────────┤
│  解像度:  [1280x720 ▼]  │
│  FPS:     [15 ▼]        │
│  明るさ:  [━━━●━━━]     │
│  コントラスト: [━━●━━━━] │
│                          │
│       [適用]  [リセット] │
└──────────────────────────┘
```

### 5.4 認証画面

```
┌──────────────────────────┐
│  🐾 Pet Camera           │
├──────────────────────────┤
│                          │
│  アクセストークンを       │
│  入力してください         │
│                          │
│  [________________]      │
│                          │
│       [接続]             │
│                          │
│  ──── または ────        │
│                          │
│  [🔑 パスキーでログイン]  │ ← パスキー登録済みの場合のみ表示
│                          │
└──────────────────────────┘
```

### 5.5 飼い主表示画面（Phase 2: `/display`）

ケージ横の PC ブラウザで開く画面。飼い主のスマホから送信された映像をフルスクリーンで表示する。

```
┌─────────────────────────────────────────────────┐
│                                              [⚙] │  ← 設定ボタン（右上、半透明）
│                                                   │
│                                                   │
│                                                   │
│             飼い主の映像                           │  ← 画面全体に表示
│           (Socket.IO 受信)                         │    （アスペクト比維持、余白は黒）
│                                                   │
│                                                   │
│                                                   │
│   接続待機中... / 映像受信中                       │  ← ステータス表示（最小限）
└─────────────────────────────────────────────────┘
```

- **背景色**: 黒（ペットの気を散らさないよう最小限のUI）
- **映像表示**: 画面全体に `width:100%; height:100%` + `object-fit:contain` で最大表示（アスペクト比維持、余白は黒）
- **音声**: PC スピーカーから飼い主の声を自動再生（別途操作不要）
- **ステータス**: 画面下部に小さく接続状態を表示。映像受信中は自動的に非表示
- **操作**: F11 等でブラウザをフルスクリーンにして使用することを想定
- **設定ボタン**: 右上に半透明の⚙ボタン。ホバーで可視化。クリックで設定パネルを表示
- **パスキー登録**: 設定パネル内にパスキー登録ボタンを配置。PC のブラウザから直接パスキーを登録でき、次回以降のログインが簡単になる
- **認証**: 未認証の場合はログイン画面（`login.html`）にリダイレクト（JSON エラーではなく HTML ページを返す）

### 5.6 スマホ側の送信コントロール（Phase 2 追加UI）

既存のメイン画面（5.1）に「顔を見せる」機能を追加する。

```
┌─────────────────────────────────────────────────┐
│  🐾 Pet Camera    [↻ 画面更新]  ● LIVE 00:03:42 │
├─────────────────────────────────────────────────┤
│ ┌────────┐                                       │
│ │ 自分の  │  ← PiP: 左上ワイプ表示               │
│ │ カメラ  │    「顔を見せる」ON 時のみ表示          │
│ └────────┘    (120px幅、角丸、半透明ボーダー)      │
│            ┌──────────────────────┐               │
│            │    ライブ映像         │               │
│            │    (MJPEG)           │               │
│            └──────────────────────┘               │
├─────────────────────────────────────────────────┤
│  [🔊 聞く ON/OFF]  [🎤 話す (押している間)]       │  ← 既存 音声コントロール
│  音量: [━━━●━━━]                                 │
├─────────────────────────────────────────────────┤
│  [📹 顔を見せる ON/OFF]                           │  ← Phase 2 追加
│  送信中: 640x480 / 10fps / 接続PC: 1台            │  ← Phase 2 ステータス
├─────────────────────────────────────────────────┤
│  [📷 スナップショット]  [💾 保存]  [⚙ 設定]      │  ← 既存 コントロールバー
└─────────────────────────────────────────────────┘
```

| ボタン / UI | 動作 | 説明 |
|------------|------|------|
| 📹 顔を見せる | トグル（ON/OFF） | ON にするとフロントカメラ映像の送信を開始。同時にマイク音声も常時送信される（Talk 常時ON） |
| PiP ワイプ | 「顔を見せる」連動 | ON 時にメイン映像エリアの左上にフロントカメラのプレビュー（120px幅）を小窓表示。OFF 時は非表示。映像は左右反転（鏡像） |

### 5.7 レスポンシブ対応

- **デスクトップ（Phase 1 ビューワー）**: 映像を最大表示
- **デスクトップ（Phase 2 飼い主表示）**: 全画面黒背景に映像のみ表示
- **モバイル（主要ユースケース）**: 映像を画面幅にフィット、音声コントロール・操作ボタンは下部に固定
- **PWA スタンドアロン対応**: JavaScript で `window.innerHeight` を計測し CSS 変数 `--app-height` に設定。`100dvh` が Android PWA モードで不正確なため、実際の可視領域高さを使用する。ヘッダー・コントロール・フッターは `flex-shrink: 0` で固定高、映像エリアのみが残り領域にフィット（`min-height: 0` + absolute配置の `<img>`）

### 5.8 PWA 対応（Phase 3）

スマートフォンのホーム画面にアプリアイコンを追加し、ブラウザの URL バーなしのスタンドアロンモードで起動できるようにする。

#### 対応プラットフォーム

| プラットフォーム | 対応ブラウザ | ホーム画面追加 | スタンドアロン起動 |
|-----------------|------------|--------------|------------------|
| Android | Chrome | manifest.json による自動インストールバナー | `display: standalone` |
| iOS | Safari | `apple-mobile-web-app-capable` メタタグ | ステータスバー: `black-translucent` |

#### 構成ファイル

- **manifest.json**: アプリ名・アイコン・表示モード・テーマカラーを定義
- **sw.js（Service Worker）**: アプリシェル（HTML・CSS・JS・アイコン）をキャッシュ。ストリーミングデータ（MJPEG・WebSocket・API）はキャッシュしない
- **アイコン**: 192x192（Android 標準）、512x512（スプラッシュスクリーン）、180x180（iOS apple-touch-icon）

#### iOS 固有の設定

```html
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Pet Camera">
<link rel="apple-touch-icon" href="/static/img/apple-touch-icon.png">
```

#### Service Worker 戦略

| リソース種別 | キャッシュ戦略 | 理由 |
|-------------|-------------|------|
| ナビゲーション（HTML） | Network-first | 認証チェックを最優先。オフライン時はキャッシュからフォールバック |
| 静的アセット（CSS/JS/画像） | Cache-first | 変更頻度が低く、キャッシュから高速に提供 |
| ストリーミング・API | キャッシュしない | リアルタイムデータはキャッシュ不適 |

---

## 6. API 設計

### 6.1 エンドポイント一覧

ストリーミングサーバーが提供する HTTP エンドポイント:

| メソッド | パス | 認証 | 説明 |
|---------|------|------|------|
| GET | `/` | 不要 | 認証画面（トークン未検証時）/ Web ビューワー（検証済み時） |
| GET | `/video_feed` | 必要 | MJPEG ストリーム |
| GET | `/snapshot` | 必要 | 現在フレームを JPEG でダウンロード（サーバーに保存しない） |
| POST | `/api/snapshots` | 必要 | 現在フレームをサーバーに保存し、保存結果を返す |
| GET | `/api/snapshots` | 必要 | 保存済みスナップショット一覧を取得 |
| GET | `/api/snapshots/<filename>` | 必要 | 保存済みスナップショットを取得 |
| DELETE | `/api/snapshots/<filename>` | 必要 | 保存済みスナップショットを削除 |
| GET | `/api/status` | 必要 | サーバーステータス（JSON） |
| GET | `/api/settings` | 必要 | 現在のカメラ設定を取得 |
| PATCH | `/api/settings` | 必要 | カメラ設定を部分更新 |
| POST | `/api/auth` | 不要 | トークン検証。成功時にセッションCookieを発行（レート制限あり） |
| POST | `/api/logout` | 必要 | セッションを無効化し Cookie を削除 |
| POST | `/api/webauthn/register/options` | 必要 | WebAuthn 登録用チャレンジを生成 |
| POST | `/api/webauthn/register` | 必要 | WebAuthn クレデンシャルを検証・保存 |
| POST | `/api/webauthn/login/options` | 不要 | WebAuthn 認証用チャレンジを生成 |
| POST | `/api/webauthn/login` | 不要 | WebAuthn 認証レスポンスを検証し、成功時にセッションCookieを発行 |
| GET | `/api/webauthn/credentials` | 必要 | 登録済みパスキーの件数を取得 |
| GET | `/display` | 必要 | 飼い主表示画面（Phase 2）。未認証時はログイン画面にリダイレクト。設定パネルからパスキー登録可能 |

認証方式: リクエストヘッダー `Authorization: Bearer <token>` またはセッション Cookie。

#### セッション Cookie 仕様

| 属性 | 値 | 説明 |
|------|-----|------|
| Cookie名 | `pet_camera_session` | — |
| `HttpOnly` | `true` | JavaScript からのアクセスを禁止（XSS 対策） |
| `Secure` | `true` | HTTPS 接続時のみ送信 |
| `SameSite` | `Strict` | クロスサイトリクエストでは送信しない（CSRF 対策） |
| 有効期限 (TTL) | 24時間（通常）/ 30日間（`/display` 用） | 通常セッションは24時間後に自動失効。`/display` ページ用セッションは長期運用のため30日間有効（後述） |
| パス | `/` | 全エンドポイントに適用 |

#### ログアウト・セッション無効化

| 操作 | 動作 |
|------|------|
| ブラウザを閉じる | Cookie は残るが、TTL 到達後に自動失効 |
| `POST /api/logout` | サーバー側でセッションを即座に無効化し、`Set-Cookie` で Cookie を削除 |
| トークン変更 | 環境変数 `PET_CAMERA_TOKEN` を変更してサーバー再起動すると、全既存セッションが無効化される |

#### `/display` 用長期セッション（Phase 2）

ケージ横 PC での無人運用を想定し、`/display` ページ用のセッションは通常より長い TTL を適用する。

| 項目 | 仕様 |
|------|------|
| 適用条件 | `/display` ページへの初回アクセス時にセッションを発行 |
| TTL | 30日間 |
| 自動延長 | Socket.IO `/video` namespace の接続が維持されている間、TTL を自動延長（heartbeat ごとに更新） |
| 失効時の動作 | `/display` ページが自動的にログイン画面にリダイレクト。再認証後に `/display` へ復帰 |

> **注意**: 長期セッションはセキュリティリスクがやや高まるが、Tailscale VPN 内でのみアクセス可能な前提であり、利便性を優先する。

### 6.2 WebSocket イベント（音声通信）

接続先: `wss://<マシン名>.<tailnet名>.ts.net:5555/audio`（SocketIO namespace）

> **注意**: `ws://`（非暗号化）は開発環境（localhost）でのみ使用可。本番運用では必ず `wss://` を使用すること。HTTPS ページから `ws://` への接続はブラウザの Mixed Content ポリシーによりブロックされる。

#### セッション管理

Flask-SocketIO は `manage_session=False` で初期化する。これにより Flask 標準のセッション管理を使用し、Flask 3.1+ の `RequestContext.session` プロパティ変更との互換性を確保する。Socket.IO ハンドラ内では Flask セッションの読み取りのみ行い、書き込みは行わない。

#### 認証

Socket.IO ハンドシェイク時に認証を必須とする。以下のいずれかで認証する:

1. **セッション Cookie**: HTTP API で認証済みの場合、ハンドシェイクに Cookie が自動付与される（推奨）
2. **Bearer トークン**: `auth` パラメータでトークンを送信する — `io({ auth: { token: "..." } })`

認証失敗時の動作:

| 状況 | サーバーの応答 |
|------|--------------|
| トークン/Cookie 未提供 | `connect_error` イベントを送信し即座に切断。`{"code": "AUTH_REQUIRED", "message": "Authentication required"}` |
| トークン/Cookie 無効 | `connect_error` イベントを送信し即座に切断。`{"code": "AUTH_INVALID", "message": "Invalid authentication"}` |

#### イベント一覧

| イベント名 | 方向 | ペイロード | 説明 |
|-----------|------|-----------|------|
| `audio_stream` | サーバー → クライアント | `binary (PCM 16bit, 16kHz, mono)` | 家の音声データ（マイク入力） |
| `audio_talk` | クライアント → サーバー | `binary (PCM 16bit, 16kHz, mono)` | ユーザーの声のデータ（スピーカー出力） |
| `audio_listen_start` | クライアント → サーバー | なし | 音声リスニング開始を要求 |
| `audio_listen_stop` | クライアント → サーバー | なし | 音声リスニング停止を要求 |
| `audio_talk_start` | クライアント → サーバー | なし | トークスロットの取得を要求 |
| `audio_talk_stop` | クライアント → サーバー | なし | トークスロットの解放 |
| `audio_status` | サーバー → クライアント | `{"listening": bool, "talking": bool}` | 音声状態の通知 |

音声フォーマット:
- サンプルレート: 16,000 Hz
- ビット深度: 16bit（リトルエンディアン）
- チャンネル数: モノラル（1ch）
- チャンクサイズ: 1024 サンプル（64ms/チャンク）

### 6.3 WebSocket イベント（映像送信 — Phase 2）

接続先: `wss://<マシン名>.<tailnet名>.ts.net:5555/video`（SocketIO namespace）

スマホのフロントカメラ映像をサーバー経由で PC 表示画面へリレーするための namespace。

#### 認証

`/audio` namespace と同様に、Socket.IO ハンドシェイク時にセッション Cookie または Bearer トークンで認証する。

#### 役割モデル（認可）

`/video` namespace に接続するクライアントは、接続時に `role` を宣言する:

| 役割 | 宣言方法 | 許可されるイベント |
|------|---------|------------------|
| `sender` | `io({ auth: { role: 'sender' } })` | `video_send_start`, `video_send_stop`, `video_frame`（送信） |
| `display` | `io({ auth: { role: 'display' } })` | `display_join`, `display_leave`, `video_frame`（受信のみ） |

- `role` 未指定の場合はサーバーが `connect_error` で切断する
- `sender` が `display_join` を送信した場合は無視される（逆も同様）

#### 単一送信者制御

サーバーは `active_sender_sid` を管理し、同時に1台のみ映像送信を許可する。

| 状態遷移 | トリガー | 動作 |
|---------|---------|------|
| 送信権取得 | `video_send_start` 受信時、`active_sender_sid` が空 | 要求元の SID を `active_sender_sid` に設定。`video_status` で `sending: true` を全クライアントに通知 |
| 送信権拒否 | `video_send_start` 受信時、`active_sender_sid` が他 SID | 要求元に `video_error` イベントを送信: `{"code": "SENDER_BUSY", "message": "Another device is already sending"}` |
| 送信権解放（正常） | `video_send_stop` 受信 | `active_sender_sid` をクリア。`video_status` で `sending: false` を通知 |
| 送信権解放（異常） | `disconnect` イベント（回線断・アプリ強制終了） | 切断した SID が `active_sender_sid` と一致する場合、自動解放。`video_status` で `sending: false` を通知 |

#### 排他セッション制御（デバイス単位）

1台のスマホが「聞く」「話す」「顔を見せる」のいずれかを使用中は、同一スマホでは3機能すべてを同時に利用できるが、他のスマホからはいずれの機能も利用できない。サーバーはクライアントの IP アドレス（Tailscale VPN の 100.x.x.x）でデバイスを識別する。

| 状態 | 動作 |
|------|------|
| 排他なし（`exclusive_ip` 未設定） | 最初に機能を使用したデバイスの IP を `exclusive_ip` に設定し、全クライアントに `exclusive_status` を通知 |
| 排他保持中（同一 IP） | 「聞く」「話す」「顔を見せる」を自由に同時利用可能 |
| 排他保持中（他 IP） | `audio_listen_start` / `audio_talk_start` は `{"error": "exclusive_blocked"}` で拒否。`video_send_start` は `{"code": "EXCLUSIVE_BLOCKED"}` で拒否。UI 上でバナー「他のデバイスが操作中のため、操作できません」を表示し、3ボタンすべてを disabled にする |
| 排他解放 | 保持デバイスの全機能が停止（リスナー0・トーク停止・映像停止）した時点で `exclusive_ip` をクリアし、全クライアントに `exclusive_status` を通知 |
| 排他保持デバイスの切断 | `disconnect` ハンドラで機能をクリーンアップし、アクティブな機能が残らなければ排他を自動解放 |

**イベント: `exclusive_status`**（サーバー → クライアント、`/audio` namespace）

| フィールド | 型 | 説明 |
|-----------|-----|------|
| `blocked` | `bool` | `true`: 他デバイスが排他保持中（このクライアントは操作不可）。`false`: 操作可能 |

> **注意**: 同一スマホ上では「顔を見せる」中でも「聞く」「話す」が利用できる。ハウリング防止の自動制御は行わない。

#### イベント一覧

| イベント名 | 方向 | ペイロード | 説明 |
|-----------|------|-----------|------|
| `video_frame` | クライアント → サーバー | `binary (JPEG)` | スマホが送信するフロントカメラの JPEG フレーム（`sender` 役割のみ） |
| `video_frame` | サーバー → クライアント | `binary (JPEG)` | サーバーが `/display` クライアントへリレーする JPEG フレーム（`display` 役割のみ） |
| `video_send_start` | クライアント → サーバー | `{"width": int, "height": int, "fps": int}` | スマホがカメラ送信を開始（`sender` 役割のみ）。送信権を取得 |
| `video_send_stop` | クライアント → サーバー | なし | スマホがカメラ送信を停止。送信権を解放 |
| `display_join` | クライアント → サーバー | なし | PC 表示クライアントが `/display` ルームに参加（`display` 役割のみ） |
| `display_leave` | クライアント → サーバー | なし | PC 表示クライアントが `/display` ルームから退出 |
| `video_status` | サーバー → クライアント | `{"sending": bool, "display_clients": int, "resolution": str, "fps": int}` | 映像送信の状態通知 |
| `video_error` | サーバー → クライアント | `{"code": str, "message": str}` | エラー通知（`SENDER_BUSY` 等） |

映像フォーマット:
- エンコード: JPEG（`canvas.toBlob('image/jpeg', quality)`）
- 解像度: 640x480（スマホのフロントカメラ。帯域節約のため）
- JPEG 品質: 0.6（帯域と画質のバランス）
- フレームレート: 10fps（スマホ側で制御。`setInterval` で 100ms ごとにキャプチャ）
- 1フレームあたりのサイズ目安: 30〜50KB（640x480, 品質0.6）
- 1フレームの最大許容サイズ: 200KB（超過フレームはサーバーがドロップ）
- 最大受信レート: 15fps（超過分はサーバーがドロップ。DoS 防御）
- 帯域使用量目安: 300〜500KB/s（10fps時）

### 6.4 レスポンス・エラー仕様

#### 共通エラー形式

すべてのエラーレスポンスは以下の JSON 形式で返す:

```json
{
  "error": {
    "code": "INVALID_PARAMETER",
    "message": "brightness must be between 0 and 100"
  }
}
```

#### HTTP ステータスコード

| コード | 用途 |
|--------|------|
| 200 | 成功 |
| 400 | リクエスト不正（バリデーションエラー、不明なパラメータ） |
| 401 | 認証トークン未提供・無効 |
| 429 | レート制限超過（認証試行回数の上限到達） |
| 404 | リソース未検出（存在しないスナップショット等） |
| 500 | サーバー内部エラー（カメラ異常等） |

#### エラーコード一覧

| コード | 説明 |
|--------|------|
| `AUTH_REQUIRED` | 認証トークンが未提供 |
| `AUTH_INVALID` | 認証トークンが無効 |
| `RATE_LIMITED` | 認証試行回数の上限超過（IP単位で一時ブロック中） |
| `INVALID_PARAMETER` | パラメータの値が許容範囲外 |
| `UNKNOWN_PARAMETER` | 未定義のパラメータが送信された |
| `CAMERA_ERROR` | カメラの接続・取得に失敗 |
| `STORAGE_ERROR` | スナップショットの保存・読込に失敗 |
| `NOT_FOUND` | 指定されたリソースが存在しない |

### 6.5 レスポンス例

#### POST `/api/auth`

リクエスト:
```json
{
  "token": "my-secret-token"
}
```

成功レスポンス (200):
```json
{
  "authenticated": true
}
```

失敗レスポンス (401):
```json
{
  "error": {
    "code": "AUTH_INVALID",
    "message": "Invalid token"
  }
}
```

レート制限超過レスポンス (429):
```json
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Too many authentication attempts. Try again in 300 seconds.",
    "retry_after_seconds": 300
  }
}
```

#### `/api/auth` レート制限仕様

| 項目 | 仕様 |
|------|------|
| 制限単位 | クライアント IP アドレスごと |
| 許容回数 | 5回 / 5分間 |
| 超過時の動作 | HTTP 429 を返し、該当 IP からの認証試行を 5分間ブロック |
| カウント対象 | 失敗した認証試行のみ（成功時はカウントリセット） |
| 監査ログ | 連続3回失敗時にログレベル WARNING で記録。5回到達（ブロック発動）時に ERROR で記録 |

#### GET `/api/status`

```json
{
  "status": "running",
  "uptime_seconds": 3842,
  "fps": 14.8,
  "resolution": "1280x720",
  "clients_connected": 1,
  "camera_index": 0,
  "audio": {
    "microphone_active": true,
    "speaker_active": false,
    "listening_clients": 1
  }
}
```

#### GET `/api/settings`

```json
{
  "resolution": {
    "width": 1280,
    "height": 720
  },
  "fps": 15,
  "brightness": 50,
  "contrast": 50
}
```

#### PATCH `/api/settings`

部分更新をサポートする。送信されたフィールドのみ更新する。

リクエスト（例: 明るさだけ変更）:
```json
{
  "brightness": 70
}
```

成功レスポンス (200): 更新後の全設定を返す:
```json
{
  "resolution": {
    "width": 1280,
    "height": 720
  },
  "fps": 15,
  "brightness": 70,
  "contrast": 50
}
```

#### パラメータ制約

| パラメータ | 型 | 許容値 | デフォルト |
|-----------|-----|--------|-----------|
| `resolution.width` | int | 640, 1280, 1920 | 1280 |
| `resolution.height` | int | 480, 720, 1080 | 720 |
| `fps` | int | 5, 10, 15, 30 | 15 |
| `brightness` | int | 0〜100 | 50 |
| `contrast` | int | 0〜100 | 50 |

> `resolution` は `width` と `height` を必ずセットで送信すること。許容される組み合わせは `640x480`, `1280x720`, `1920x1080` のみ。

#### POST `/api/snapshots`

リクエストボディ: なし

成功レスポンス (200):
```json
{
  "filename": "snapshot_20260219_143052_123.jpg",
  "size_bytes": 85432,
  "timestamp": "2026-02-19T14:30:52+09:00",
  "storage_used_bytes": 12345678,
  "storage_limit_bytes": 524288000
}
```

#### GET `/api/snapshots`

```json
{
  "snapshots": [
    {
      "filename": "snapshot_20260219_143052_123.jpg",
      "size_bytes": 85432,
      "timestamp": "2026-02-19T14:30:52+09:00"
    }
  ],
  "total_count": 1,
  "storage_used_bytes": 85432,
  "storage_limit_bytes": 524288000
}
```

### 6.6 スナップショット保存仕様

| 項目 | 仕様 |
|------|------|
| 保存先 | `snapshots/` ディレクトリ |
| ファイル命名 | `snapshot_YYYYMMDD_HHmmss_fff.jpg`（サーバー時刻） |
| 保存上限 | 500 MB |
| 削除ポリシー | FIFO（保存上限超過時に最も古いファイルから自動削除） |
| 保存タイミング | `POST /api/snapshots` 呼び出し時のみ（自動保存はしない） |

---

## 7. ディレクトリ構成

```
pet-camera/
├── docs/
│   ├── SPECIFICATION.md        # 本仕様書
│   └── REVIEW_SPCIFICATION.md  # レビュー結果
├── server/
│   ├── app.py                  # Flask アプリケーション（エントリーポイント）
│   ├── camera.py               # カメラ制御モジュール
│   ├── audio.py                # 音声入出力モジュール（マイク・スピーカー制御）
│   ├── auth.py                 # 認証ミドルウェア
│   ├── webauthn_auth.py        # WebAuthn（パスキー）登録・認証モジュール
│   ├── config.py               # 設定管理
│   └── requirements.txt        # Python 依存パッケージ
├── data/
│   └── webauthn_credentials.json  # WebAuthn クレデンシャル保存（.gitignore対象）
├── static/
│   ├── manifest.json            # PWA マニフェスト
│   ├── sw.js                    # Service Worker（アプリシェルキャッシュ）
│   ├── css/
│   │   └── style.css           # スタイルシート
│   ├── js/
│   │   ├── app.js              # フロントエンドロジック（映像・UI）
│   │   ├── audio.js            # 音声制御（Web Audio API / getUserMedia）
│   │   └── display.js          # Phase 2: 飼い主表示画面の映像受信・描画ロジック
│   └── img/
│       ├── icon-192.png        # PWA アイコン (192x192)
│       ├── icon-512.png        # PWA アイコン (512x512)
│       ├── apple-touch-icon.png # iOS ホーム画面アイコン (180x180)
│       └── favicon.png         # ファビコン (32x32)
├── templates/
│   ├── index.html              # メインページテンプレート
│   ├── login.html              # 認証ページテンプレート
│   └── display.html            # Phase 2: 飼い主表示画面テンプレート
├── certs/                      # TLS証明書・秘密鍵（.gitignore対象）
├── logs/                       # アクセスログ・アプリログ（.gitignore対象）
├── snapshots/                  # スナップショット保存先（.gitignore対象）
├── .gitignore
├── README.md
├── setup.bat                   # 初期セットアップスクリプト
├── install-service.bat         # NSSM サービス登録スクリプト
└── renew-cert.bat              # TLS証明書更新スクリプト（タスクスケジューラ登録用）
```

---

## 8. セキュリティ設計

### 8.1 多層防御アーキテクチャ

```
第1層: Tailscale VPN
  インターネット ──×──▶ 自宅PC:5555    ← ポート開放しない、外部から到達不可
  Tailscale VPN  ──✓──▶ 100.x.x.x:5555 ← VPN 内部アドレスでのみアクセス可

第2層: アプリケーション認証トークン
  トークン未提供 ──×──▶ API/ストリーム  ← 401 Unauthorized
  正しいトークン ──✓──▶ API/ストリーム  ← アクセス許可
```

### 8.2 ネットワークセキュリティ（Tailscale VPN）

- **ゼロトラスト**: Tailscale はデバイス単位で認証。承認されたデバイスのみ接続可能
- **暗号化**: WireGuard プロトコルによるエンドツーエンド暗号化
- **ポート非公開**: ルーターでのポートフォワーディング一切不要
- **デバイス管理**: Tailscale 管理画面で接続デバイスを管理・取り消し可能

### 8.3 パスキー認証（WebAuthn / FIDO2）

#### 概要

初回トークン認証後、デバイスの生体認証（指紋認証・顔認証）を登録すると、次回以降はトークン入力不要でパスキーのみでログインできる。

#### 認証フロー

```
【パスキー登録（初回のみ）】
1. トークンでログイン → メイン画面の設定パネルを開く
2. 「このデバイスを登録」ボタンをタップ
3. サーバーが登録チャレンジを生成 (POST /api/webauthn/register/options)
4. ブラウザが生体認証をリクエスト → ユーザーが指紋/顔で認証
5. 公開鍵クレデンシャルをサーバーに送信 (POST /api/webauthn/register)
6. サーバーが検証し、公開鍵を data/webauthn_credentials.json に保存

【パスキーログイン（2回目以降）】
1. ログイン画面で「パスキーでログイン」ボタンをタップ
2. サーバーが認証チャレンジを生成 (POST /api/webauthn/login/options)
3. ブラウザが生体認証をリクエスト → ユーザーが指紋/顔で認証
4. 署名をサーバーに送信 (POST /api/webauthn/login)
5. サーバーが公開鍵で署名を検証 → セッション Cookie 発行
```

#### 技術仕様

| 項目 | 仕様 |
|------|------|
| プロトコル | WebAuthn Level 2 (W3C 標準) |
| サーバーライブラリ | py-webauthn >= 2.0 |
| Relying Party ID | TLS 証明書のドメイン名（例: `lenovo411.tail499884.ts.net`） |
| ユーザー検証 | required（生体認証必須） |
| Resident Key | preferred |
| クレデンシャル保存 | `data/webauthn_credentials.json`（サーバーローカル） |
| 対応ブラウザ | Chrome (Android), Safari (iOS) の最新版 |

#### セキュリティ特性

- **生体情報はサーバーに送信されない**: デバイス内で照合し、暗号署名のみが送信される
- **デバイスごとに登録が必要**: 他人のデバイスでは使用不可
- **トークン認証は常にフォールバックとして利用可能**: 新しいデバイス追加やパスキー非対応環境向け

### 8.4 アプリケーションセキュリティ

| 対策 | 説明 |
|------|------|
| トークン認証 | 環境変数 `PET_CAMERA_TOKEN` に設定した文字列で認証。初回アクセス時にブラウザで入力し、セッション Cookie を発行 |
| パスキー認証 | WebAuthn による生体認証。初回トークン認証後にデバイスを登録し、次回以降パスキーでログイン |
| バインドアドレス制限 | Flask サーバーを Tailscale の仮想IPアドレス（`100.x.x.x`）にのみバインド |
| アクセスログ | 全リクエストをログファイルに記録（日時・クライアントIP・メソッド・パス・ステータスコード） |
| CORS 制限 | 同一オリジンのみ許可 |
| 入力バリデーション | 設定変更 API のパラメータを許容値テーブル（6.5節）に基づき検証 |
| ディレクトリトラバーサル防止 | スナップショットのファイル名をサニタイズ。`snapshots/` 以外のパスを拒否 |

### 8.5 アクセスログ形式

```
2026-02-19T14:30:52+09:00 | 100.100.1.51 | GET /video_feed | 200
2026-02-19T14:30:55+09:00 | 100.100.1.51 | POST /api/snapshots | 200
2026-02-19T14:31:00+09:00 | 100.100.1.99 | GET /api/status | 401
```

- 保存先: `logs/access.log`
- ローテーション: 日次ローテーション、7日分保持

### 8.6 アクセス手順

1. 自宅PCに Tailscale をインストール・ログイン
2. スマートフォン（夫・妻）に Tailscale アプリをインストール・同一アカウントでログイン
3. スマホのブラウザから `https://<マシン名>.<tailnet名>.ts.net:5555` にアクセス（HTTPS 必須。`http://` は開発環境でのみ使用）
4. 認証トークンを入力してログイン
5. → Tailscale 未接続 または トークン未認証 のデバイスからは一切アクセスできない

---

## 9. 非機能要件

| 項目 | 要件 | 測定条件 |
|------|------|---------|
| 映像レイテンシ | 1秒以内（LAN内）、3秒以内（モバイル回線経由VPN） | クライアント2台同時接続、720p/15fps、5分間の平均値で評価 |
| 音声レイテンシ | 500ms以内（LAN内）、1秒以内（モバイル回線経由VPN） | クライアント1台がリスニング中、5分間の平均値で評価 |
| 解像度 | 720p（1280×720）をデフォルトとする | — |
| フレームレート | 15fps をデフォルトとする（帯域節約） | — |
| 同時接続数 | 2〜3クライアントを想定 | — |
| CPU使用率 | アイドル時: 5%以下、映像配信時: 20%以下、映像+音声配信時: 30%以下 | 2クライアント同時接続・720p/15fps・音声ON、5分間の平均値で評価 |
| ストレージ | スナップショット保存: 最大 500MB（FIFO自動削除） | — |
| 可用性 | PC 起動中は常時稼働。異常終了時は自動再起動（NSSM） | — |
| ログ保持 | アクセスログ: 日次ローテーション、7日分保持 | — |
| ブラウザ対応 | Chrome, Safari (iOS), Edge の最新版 | — |
| 逆方向映像レイテンシ（Phase 2） | 500ms以内（LAN内）、1秒以内（モバイル回線経由VPN） | スマホ1台送信・PC1台表示、640x480/10fps、5分間の平均値で評価 |
| 逆方向映像帯域（Phase 2） | 300〜500KB/s | 640x480, JPEG品質0.6, 10fps |

### 9.1 参考計測環境

上記の測定は以下の環境を想定する:

- **PC**: Windows 11、Intel Core i5 相当以上、RAM 8GB 以上
- **ネットワーク**: 自宅回線 100Mbps 以上、モバイル 4G/5G
- **カメラ**: 720p 対応 USB カメラまたは内蔵カメラ

---

## 10. 可用性・運用設計

### 10.1 プロセス管理（NSSM）

タスクスケジューラではなく NSSM（Non-Sucking Service Manager）で Windows サービスとして登録し、以下を実現する:

| 項目 | 設定 |
|------|------|
| サービス名 | `PetCameraServer` |
| 起動種別 | 自動（PC起動時に自動開始） |
| 異常終了時 | 自動再起動（5秒後にリトライ） |
| 再起動上限 | 3回/10分（上限到達後は停止してログに記録） |
| 標準出力ログ | `logs/stdout.log` |
| 標準エラーログ | `logs/stderr.log` |
| ログローテーション | NSSM のファイルローテーション設定で 10MB 上限 |

### 10.2 ヘルスチェック

- サーバー起動後、カメラが接続されていない場合はログにエラーを出力して待機（クラッシュせずリトライ可能にする）
- `/api/status` エンドポイントで稼働状況を随時確認可能

---

## 11. 接続維持・自動復旧設計

外出中にサーバーを起動し、帰宅するまで無人で安定稼働することを最重要要件とする。いかなる障害が発生しても、手動操作なしで接続が復旧する設計とする。

### 11.1 障害カテゴリと対策方針の全体像

| # | 障害カテゴリ | 影響範囲 | 対策方針 |
|---|------------|---------|---------|
| R-01 | Socket.IO 接続断（クライアント側） | 映像・音声が途切れる | クライアント側で自動再接続（指数バックオフ） |
| R-02 | モバイルブラウザのバックグラウンド化 | スマホからの映像・音声送信が停止 | Page Visibility API による検知 + 復帰時に自動再開 |
| R-03 | ディスプレイ側ブラウザのスリープ・画面オフ | PC 画面が消灯し映像が見えなくなる | Wake Lock API + visibility change 検知で再取得 |
| R-04 | サーバープロセスのクラッシュ | 全クライアントが切断 | NSSM による自動再起動 + クライアント側自動再接続 |
| R-05 | サーバー内未捕捉例外 | 特定機能が停止またはプロセスが終了 | 全 Socket.IO ハンドラに try-catch + グローバル例外ハンドラ |
| R-06 | カメラデバイス障害 | MJPEG 映像が停止 | カメラスレッドの自動リトライ（既存）+ エラー通知強化 |
| R-07 | 音声デバイス障害 | マイク入力またはスピーカー出力が停止 | デバイスの自動リトライ + エラー状態通知 |
| R-08 | ネットワーク障害（Tailscale/WiFi） | 全通信が途絶 | クライアント側自動再接続 + ネットワーク復帰検知 |
| R-09 | Windows スリープ・休止状態 | サーバーが停止し全クライアント切断 | スリープ無効化の事前設定 + 万一の復帰後自動回復 |
| R-10 | メモリリーク・リソース枯渇 | 長時間運用でサーバーが応答不能 | 孤立リソースの定期クリーンアップ + メモリ監視 |
| R-11 | セッション期限切れ | ページがログアウト状態に戻る | 長期セッション（30日）+ 自動延長 + 透過的再認証 |
| R-12 | TLS 証明書期限切れ | HTTPS 接続が拒否される | 証明書期限の事前チェック + タスクスケジューラによる自動更新 |

### 11.2 クライアント側 Socket.IO 自動再接続

現状、Socket.IO のデフォルト再接続（`reconnection: true`）は有効だが、アプリケーションレベルの状態復旧（ルーム再参加、リスニング再開等）が実装されていない。以下を全クライアント（`display.js`、`app.js`、`audio.js`）に実装する。

#### 再接続パラメータ

| パラメータ | 値 | 説明 |
|-----------|-----|------|
| `reconnection` | `true` | 自動再接続を有効化（Socket.IO デフォルト） |
| `reconnectionAttempts` | `Infinity` | 無制限にリトライ |
| `reconnectionDelay` | `1000` (1秒) | 初回リトライまでの待機時間 |
| `reconnectionDelayMax` | `30000` (30秒) | 最大待機時間（指数バックオフの上限） |
| `randomizationFactor` | `0.3` | ジッター（複数クライアントの再接続が集中するのを防止） |
| `timeout` | `20000` (20秒) | 接続タイムアウト |

#### 状態復旧フロー

再接続成功時（`connect` イベント）に、切断前の状態を自動的に復旧する:

```
【display.js】
reconnect → display_join 再送信 → 映像受信再開

【audio.js】
reconnect → 切断前に Listen 中だった場合 → audio_listen_start 再送信
           → 切断前に Talk 中だった場合 → audio_talk_start 再送信

【app.js (映像送信)】
reconnect → 切断前に「顔を見せる」中だった場合 → video_send_start 再送信 → フレーム送信再開
```

#### 再接続 UI フィードバック

| 状態 | 表示 |
|------|------|
| 再接続試行中 | 「再接続中...（n回目）」をステータスエリアに表示 |
| 再接続成功 | 自動的にステータスを非表示に戻す |
| 長時間切断（30秒以上） | 「接続が不安定です。ネットワークを確認してください」を表示 |

### 11.3 ブラウザ・モバイル固有の障害と対策

#### モバイルブラウザのバックグラウンド制約

スマホでブラウザをバックグラウンドにすると、OS が WebSocket 接続やタイマーを停止する。これは OS の省電力機能であり防止できないため、フォアグラウンド復帰時に速やかに復旧する。

| 対策 | 実装箇所 | 説明 |
|------|---------|------|
| Page Visibility API による検知 | `app.js`, `audio.js` | `document.addEventListener('visibilitychange')` でバックグラウンド化・復帰を検知 |
| 復帰時の Socket.IO 再接続確認 | `app.js`, `audio.js` | `document.visibilityState === 'visible'` 時に `socket.connected` を確認し、未接続なら `socket.connect()` を呼ぶ |
| メディアストリーム再取得 | `app.js` | フロントカメラの `MediaStream` が停止している場合、`getUserMedia` を再呼び出し |
| AudioContext 再開 | `audio.js` | ブラウザが `AudioContext` を `suspended` にした場合、`audioCtx.resume()` を呼ぶ |

#### ディスプレイ側ブラウザの画面スリープ

| 対策 | 実装箇所 | 説明 |
|------|---------|------|
| Wake Lock API | `display.js` | `navigator.wakeLock.request('screen')` で画面スリープを防止（既存実装） |
| Wake Lock 再取得 | `display.js` | `visibilitychange` イベントで `visible` に戻った時、Wake Lock を再取得する |
| Wake Lock 非対応ブラウザ | 運用ガイド | Windows の電源設定で「画面の電源を切る: なし」に設定するよう案内 |

### 11.4 サーバー側プロセス復旧

#### NSSM 自動再起動設定

NSSM は既にサービス化に使用しているが、以下の設定を明示的に行う:

| 設定項目 | 値 | 説明 |
|---------|-----|------|
| `AppExit Default` | `Restart` | プロセス終了時の既定動作: 再起動 |
| `AppRestartDelay` | `5000` (5秒) | 再起動までの待機時間 |
| `AppThrottle` | `30000` (30秒) | 連続クラッシュ時の抑制間隔（30秒以内に再度終了した場合は待機時間を延長） |
| `AppStopMethodSkip` | `0` | 正常停止シーケンスを省略しない |

#### グローバル例外ハンドラ

サーバー内の未捕捉例外がプロセスを終了させないよう、以下を実装する:

| 対策 | 説明 |
|------|------|
| Socket.IO イベントハンドラの try-catch | 全 `@socketio.on()` ハンドラを try-catch で囲み、例外をログに記録して処理を継続 |
| Flask エラーハンドラ | `@app.errorhandler(500)` で内部エラーをキャッチし、クライアントにエラーレスポンスを返す |
| スレッド例外のキャッチ | カメラスレッド・音声スレッドで未捕捉例外をキャッチし、スレッドを自動再起動 |

### 11.5 カメラ・音声デバイス障害と復旧

#### カメラデバイス

カメラスレッド（`camera.py`）は既にリトライ機構を持っている（5秒間隔で再試行）。追加で以下を実装する:

| 対策 | 説明 |
|------|------|
| エラーカウンタ | 連続失敗回数をカウントし、閾値（10回）到達時にログレベル ERROR で記録 |
| ステータス反映 | `/api/status` のレスポンスに `camera_error: true` を含め、クライアント UI に表示 |
| 復旧通知 | カメラが復旧した際にログに記録し、`camera_error` を解除 |

#### 音声デバイス

| 対策 | 説明 |
|------|------|
| マイク初期化リトライ | `AudioCapture.start()` 失敗時、10秒間隔でリトライ（最大無制限） |
| スピーカー初期化リトライ | `AudioPlayer.start()` 失敗時、10秒間隔でリトライ（最大無制限） |
| デバイス切断検知 | `sounddevice` のコールバック内例外をキャッチし、デバイスの再オープンを試行 |
| 音声なし稼働 | 音声デバイスが利用できなくても映像配信は継続する（音声はオプショナル） |

### 11.6 ネットワーク障害と復旧

| 障害シナリオ | 症状 | 復旧方法 |
|------------|------|---------|
| Tailscale VPN 一時切断 | 全 WebSocket が切断。MJPEG ストリームが停止 | Tailscale 自体が自動再接続する。クライアント側 Socket.IO 自動再接続（R-01）で復旧 |
| スマホの WiFi ↔ モバイル回線切り替え | IP アドレス変更により WebSocket が切断 | Socket.IO 自動再接続 + 状態復旧フロー（11.2節）で復旧 |
| PC の WiFi 一時切断 | サーバーへの到達不能 | PC のネットワーク復帰後、サーバーは自動的にリッスン再開。クライアント側が再接続 |
| パケットロス・高遅延 | 映像のフレーム欠落、音声の途切れ | Socket.IO の組み込みバッファリングで吸収。深刻な場合は切断→再接続 |

#### ネットワーク復帰検知（クライアント側）

| 対策 | 実装箇所 | 説明 |
|------|---------|------|
| `online` イベント | 全クライアント JS | `window.addEventListener('online')` でネットワーク復帰を検知し、即座に `socket.connect()` を試行 |
| `offline` イベント | 全クライアント JS | `window.addEventListener('offline')` でオフライン状態を検知し、UI に表示 |

### 11.7 Windows OS レベル障害と対策

| 障害シナリオ | 対策 |
|------------|------|
| Windows スリープ・休止状態 | 電源プランで「スリープ: なし」「休止状態: 無効」に設定する（**事前設定必須。HOW_TO_USE.md に記載**） |
| Windows Update による自動再起動 | アクティブ時間（外出中の時間帯）を設定し、自動再起動を回避。NSSM サービスは PC 再起動後に自動開始 |
| ネットワークアダプタのスリープ | デバイスマネージャーでネットワークアダプタの「電力の節約のためにこのデバイスの電源をオフにできるようにする」を無効化 |
| ブルースクリーン（BSOD） | 復旧不可。PC 再起動後に NSSM がサービスを自動開始。クライアント側は自動再接続 |
| ディスク容量不足 | スナップショットの FIFO 削除（既存）+ ログローテーション（既存）で防止。起動時にディスク残量をチェック |

### 11.8 メモリ・リソース管理

長時間（8〜12時間）の連続稼働に耐えるため、メモリリークとリソース枯渇を防止する。

| 対策 | 説明 |
|------|------|
| 孤立リスナーキューの除去 | 音声リスナー（`AudioCapture`）のキューがフル（50アイテム）になった場合、該当リスナーを除去する（既存実装） |
| Blob URL の確実な解放 | `display.js` で `URL.revokeObjectURL()` をフレームごとに呼ぶ（既存実装）。try-catch で例外時も確実に実行 |
| Socket.IO イベントリスナーの重複防止 | 再接続時に `socket.off()` で旧リスナーを解除してから `socket.on()` で再登録、またはリスナー登録は初回のみ行う |
| サーバー側切断クライアントの即時クリーンアップ | `disconnect` イベントで `_display_clients`、`_video_client_roles`、音声キューを確実に除去（既存実装を強化） |
| MediaStream トラックの確実な停止 | `getUserMedia` で取得した MediaStream のトラックを、停止時・エラー時に `track.stop()` で確実に解放 |

### 11.9 セッション・認証の維持

| 対策 | 説明 |
|------|------|
| `/display` 長期セッション | TTL 30日間。Socket.IO 接続が維持されている間は TTL を自動延長（既存設計） |
| メインページセッション | TTL 24時間。外出は通常12時間以内のため十分 |
| セッション切れ時の動線 | Socket.IO `connect_error` でセッション切れを検知した場合、UI に「セッション切れ — 再ログインしてください」を表示 |
| MJPEG ストリームの認証切れ | `<img>` タグの MJPEG ストリームが 401 を返した場合、ページリロードでログイン画面に遷移 |

### 11.10 復旧シナリオまとめ

以下に、想定される主要な障害シナリオと、自動復旧の流れをまとめる。

```
【シナリオ A: スマホの電波が一時的に途切れた】
1. Socket.IO が切断を検知
2. Socket.IO 自動再接続（1秒→2秒→4秒...最大30秒の指数バックオフ）
3. 再接続成功時:
   - audio.js: Listen/Talk 状態を復旧
   - app.js: 「顔を見せる」中だった場合、video_send_start 再送信 → フレーム送信再開
4. ユーザー操作: 不要

【シナリオ B: スマホのブラウザをバックグラウンドにした】
1. OS がタイマーと WebSocket を停止
2. フォアグラウンド復帰時:
   - visibilitychange イベント発火
   - Socket.IO 接続状態を確認 → 未接続なら再接続
   - AudioContext が suspended なら resume()
   - MediaStream が停止していたら getUserMedia 再呼び出し
   - 「顔を見せる」中だった場合、video_send_start 再送信
3. ユーザー操作: ブラウザを開くだけ

【シナリオ C: PC のネットワークが一時切断した（WiFi 再接続等）】
1. サーバーはリッスン中のまま（ソケットは残存）
2. ネットワーク復帰後、クライアントからの接続が復旧
3. 全クライアントの Socket.IO 自動再接続が発動
4. ユーザー操作: 不要

【シナリオ D: サーバープロセスがクラッシュした】
1. NSSM がプロセス終了を検知
2. 5秒後にプロセスを自動再起動
3. サーバー起動完了後、クライアント側 Socket.IO が再接続
4. 各クライアントの状態復旧フロー（11.2節）が実行
5. ユーザー操作: 不要

【シナリオ E: Windows Update で PC が再起動した】
1. PC 再起動後、NSSM サービスが自動開始
2. Tailscale が自動接続
3. サーバー起動完了後、クライアント側 Socket.IO が再接続
4. ユーザー操作: 不要（ただしスリープ設定が正しければ再起動自体が稀）

【シナリオ F: ディスプレイ PC のブラウザがフリーズした】
1. Socket.IO 接続がタイムアウトで切断
2. ブラウザが復帰した場合: Socket.IO 自動再接続 → display_join 再送信
3. ブラウザが完全にクラッシュした場合: 復旧不可（手動でブラウザを再起動する必要あり）
4. 対策: ディスプレイ PC 側ではブラウザ以外のアプリを起動しない運用を推奨
```

### 11.11 実装優先度

| 優先度 | 対策 | 理由 |
|-------|------|------|
| **P0（必須）** | Socket.IO 自動再接続 + 状態復旧（R-01） | 全障害シナリオの基盤。これがないと他の対策が機能しない |
| **P0（必須）** | Page Visibility API によるバックグラウンド復帰（R-02） | スマホ利用の最頻出障害 |
| **P0（必須）** | Wake Lock 再取得（R-03） | ディスプレイが消灯するとペットに顔が見えなくなる |
| **P0（必須）** | Socket.IO ハンドラの try-catch（R-05） | 未捕捉例外でサーバーが死なないようにする |
| **P1（重要）** | ネットワーク復帰検知 online/offline（R-08） | 再接続のトリガーを早める |
| **P1（重要）** | 音声デバイスリトライ（R-07） | 音声は重要機能だが映像が最優先 |
| **P1（重要）** | メモリリーク対策（R-10） | 長時間稼働に必要 |
| **P2（推奨）** | カメラエラー通知強化（R-06） | 既存リトライ機構があるため追加は改善レベル |
| **P2（推奨）** | セッション切れ UI 通知（R-11） | 30日セッションがあるため発生頻度は低い |
| **P2（推奨）** | ディスク残量チェック（R-10） | 500MB FIFO で枯渇リスクは低い |

---

## 12. 双方向音声の技術設計

### 12.1 音声フロー

```
【リスニング（家の音 → スマホ）】
PCマイク → sounddevice入力(16kHz) → PCMチャンク → SocketIO → リサンプリング(→48kHz) → WebAudio API → スマホスピーカー

【トーク（スマホの声 → 家）】
スマホマイク → getUserMedia → ScriptProcessor(48kHz) → リサンプリング(→16kHz) → PCMチャンク → SocketIO → sounddevice出力(16kHz) → PCスピーカー
```

> **リサンプリング**: ブラウザの AudioContext は通常 44.1kHz または 48kHz で動作し、16kHz をサポートしないことが多い。クライアント側でリニア補間によるリサンプリングを行い、サーバーとの 16kHz PCM フォーマットに変換する。

### 12.2 設計上の考慮

| 課題 | 対策 |
|------|------|
| ハウリング（エコー） | プッシュ・トゥ・トーク方式で送話と受話を分離 |
| 音声遅延 | チャンクサイズを 1024 サンプル（64ms）に設定し低遅延化 |
| 帯域使用量 | 16kHz/16bit/mono = 約 256kbps（映像と合わせても十分実用的） |
| ブラウザ制限 | getUserMedia は HTTPS または localhost でのみ利用可。Tailscale の IP 直指定は HTTP だが、ブラウザの `chrome://flags` 等で例外設定するか、自己署名証明書を導入 |
| 複数クライアント | リスニングは全クライアントに同時配信。トークは先勝ち（1クライアントのみ同時トーク可） |

### 12.3 ブラウザ音声許可への対応

`getUserMedia`（マイクアクセス）はセキュアコンテキスト（HTTPS / localhost）で動作する。Tailscale IP アドレスへの HTTP 接続では制限される場合がある。対応方針:

1. **本番（必須）**: Tailscale の MagicDNS + HTTPS 証明書機能（`tailscale cert`）を利用し、`https://<マシン名>.<tailnet名>.ts.net:5555` でアクセスする
2. **開発環境のみ**: `http://localhost:5555` でアクセスする（localhost はセキュアコンテキストとして扱われる）

### 12.4 HTTPS / TLS 実装詳細

#### TLS 終端方式

Flask に直接 SSL コンテキストを設定し、TLS を終端する（リバースプロキシは使用しない）。

```python
# app.py での TLS 設定例
ssl_context = (
    "certs/<マシン名>.<tailnet名>.ts.net.crt",
    "certs/<マシン名>.<tailnet名>.ts.net.key"
)
socketio.run(app, host="0.0.0.0", port=5555, ssl_context=ssl_context)
```

> Flask-SocketIO は `ssl_context` を指定すると HTTPS + WSS を同一ポートで同時に提供する。映像（MJPEG）・音声（WSS）・API（HTTPS）のすべてが `:5555` に統一される。

#### 証明書配置

| ファイル | 配置先 | 説明 |
|---------|--------|------|
| `<マシン名>.<tailnet名>.ts.net.crt` | `certs/` | TLS 証明書 |
| `<マシン名>.<tailnet名>.ts.net.key` | `certs/` | 秘密鍵 |

- `certs/` ディレクトリは `.gitignore` に追加する
- 秘密鍵のファイル権限は所有者のみ読み取り可に設定

#### 証明書の更新運用

| 項目 | 仕様 |
|------|------|
| 証明書の有効期限 | Tailscale 発行証明書は 90日間有効 |
| 更新方法 | `tailscale cert <マシン名>.<tailnet名>.ts.net` を再実行 |
| 更新後の反映 | サービス再起動が必要（`nssm restart PetCameraServer`） |
| 更新の自動化 | タスクスケジューラで月1回 `tailscale cert` を実行し、サービスを再起動するバッチを登録 |

#### 開発環境と本番環境の切り分け

| 項目 | 開発環境 | 本番環境 |
|------|---------|---------|
| プロトコル | HTTP + WS | HTTPS + WSS |
| ホスト | `localhost` / `127.0.0.1` | Tailscale IP / MagicDNS |
| TLS 証明書 | 不要 | 必須（`tailscale cert`） |
| マイク機能 | localhost なら動作可 | HTTPS 必須 |
| 設定方法 | 環境変数 `PET_CAMERA_ENV=development` | 環境変数 `PET_CAMERA_ENV=production`（デフォルト） |

---

## 13. 逆方向映像ストリーミングの技術設計（Phase 2）

### 13.1 映像フロー

```
【スマホ → PC（飼い主の顔をペットに見せる）】
スマホ フロントカメラ → getUserMedia(video) → <video> → <canvas>.toBlob(JPEG, 0.6) → Socket.IO /video → サーバー（リレー） → Socket.IO /video → <img>.src = Blob URL → PC ディスプレイ
```

### 13.2 設計上の考慮

| 課題 | 対策 |
|------|------|
| 帯域消費 | 640x480 + JPEG品質0.6 + 10fps で 300〜500KB/s に抑制。Tailscale VPN 内なら十分実用的 |
| 遅延 | Socket.IO バイナリ転送。サーバーはリレーのみ（デコード/再エンコードなし）で遅延を最小化 |
| フレームレート制御 | スマホ側で `setInterval` による定期キャプチャ。`requestAnimationFrame` ではなく固定間隔で帯域を安定化 |
| カメラ選択 | `facingMode: 'user'` でフロントカメラを指定。飼い主の顔を映す用途のため |
| 排他セッション制御 | デバイス単位（IP ベース）で排他制御。1台が機能使用中は他のスマホからの操作をブロック。同一スマホでは「聞く」「話す」「顔を見せる」を同時利用可能 |
| 複数スマホからの同時操作 | 先勝ち方式。1台のみ全機能を利用可。2台目以降は `exclusive_status` でブロックを通知し、UI にバナー表示 |
| PC 表示クライアント | 複数台の PC で `/display` を開くことが可能。全 display クライアントに同じフレームをブロードキャスト |
| ブラウザの自動スリープ | 映像受信中は `<video>` の再生状態を維持し、画面スリープを抑制（Screen Wake Lock API の利用を検討） |

### 13.3 Socket.IO によるリレー方式を選択した理由

| 選択肢 | 評価 |
|--------|------|
| **Socket.IO JPEG リレー（採用）** | 既存の音声アーキテクチャと同一パターン。実装がシンプル。サーバーが中継するため接続管理が容易 |
| WebRTC | P2P で低遅延だが、シグナリングサーバーの実装が必要。Tailscale VPN 内では NAT traversal 不要のためメリットが薄い |
| 逆方向 MJPEG | スマホ側に HTTP サーバーが必要になり、ブラウザでは実現困難 |

---

## 14. 開発フェーズ・実装順序

### Phase 1: MVP（本プロジェクトのスコープ）

```
Step 1: プロジェクト初期化
  - Git リポジトリ作成
  - Python 仮想環境セットアップ
  - 依存パッケージインストール

Step 2: 認証モジュール (auth.py)
  - トークン検証ミドルウェア
  - セッション Cookie 発行
  - アクセスログ記録

Step 3: カメラ制御モジュール (camera.py)
  - OpenCV でカメラ接続
  - フレーム取得ループ
  - 設定変更機能（解像度・FPS・明るさ・コントラスト）

Step 4: 音声モジュール (audio.py)
  - PyAudio でマイク入力キャプチャ
  - PyAudio でスピーカー出力再生
  - チャンク管理

Step 5: ストリーミングサーバー (app.py)
  - Flask + Flask-SocketIO サーバー構築
  - MJPEG ストリーミングエンドポイント
  - スナップショット取得・保存 API
  - ステータス API
  - 設定変更 API（PATCH、バリデーション付き）
  - WebSocket 音声ストリーミング

Step 6: Web UI (templates/ + static/)
  - 認証画面
  - レスポンシブビューワー
  - 音声コントロール（聞く・話す・音量）
  - コントロール（スナップショット・設定）
  - ステータス表示

Step 7: セキュリティ設定
  - Tailscale インストール・設定
  - HTTPS 設定（MagicDNS + tailscale cert）
  - バインドアドレス制限
  - 接続テスト

Step 8: サービス化・運用設定
  - NSSM インストール・サービス登録 (install-service.bat)
  - ログローテーション設定
  - 初期セットアップスクリプト (setup.bat)
```

### Phase 2: 飼い主表示モード

```
Step 1: サーバー側 — /video namespace 追加 (app.py)
  - Socket.IO /video namespace のハンドラ追加
  - video_frame イベントの受信・リレー処理
  - video_send_start / video_send_stop イベント処理
  - display_join / display_leave イベント処理
  - video_status 通知

Step 2: PC表示画面 (templates/display.html + static/js/display.js)
  - /display ルート追加（認証必須）
  - フルスクリーン黒背景のシンプルUI
  - Socket.IO /video namespace に接続し display_join を送信
  - video_frame イベント受信時に <img> または <canvas> で描画
  - 接続状態のステータス表示

Step 3: スマホ側 — カメラ送信機能追加 (static/js/app.js)
  - 「顔を見せる」トグルボタンの追加
  - getUserMedia でフロントカメラ取得
  - <video> → <canvas> → toBlob で JPEG エンコード
  - setInterval で定期的に video_frame イベントを送信
  - Talk 機能の常時 ON モード連動

Step 4: 音声の常時 ON 対応 (static/js/audio.js)
  - 「顔を見せる」開始時に Talk を自動開始（常時 ON）
  - 「顔を見せる」停止時に Talk を自動停止
  - プッシュ・トゥ・トークとの共存（顔を見せる中は Talk ボタン無効化）

Step 5: スタイル調整 (static/css/style.css)
  - display.html 用のフルスクリーンスタイル
  - スマホ側「顔を見せる」ボタンのスタイル
```

---

## 15. 依存パッケージ

### Python (requirements.txt)

```
opencv-python>=4.8.0
flask>=3.0.0
flask-socketio>=5.3.0
sounddevice>=0.4.6
numpy>=1.24.0
python-engineio>=4.8.0
webauthn>=2.0.0
```

### システム要件

- Python 3.10 以上
- Windows 10/11
- USB カメラまたは内蔵カメラ
- マイク（内蔵または USB / ヘッドセット）
- スピーカー（内蔵または USB / ヘッドセット）
- Tailscale クライアント
- NSSM（Non-Sucking Service Manager）

---

## 16. Tailscale セットアップ手順（参考）

1. https://tailscale.com/ でアカウント作成（無料）
2. Windows PC に Tailscale をインストール → 割り当てられた IP を確認（例: `100.100.1.50`）
3. MagicDNS を有効化し、`tailscale cert` で HTTPS 証明書を取得
4. スマートフォンに Tailscale アプリをインストール
5. 同一アカウントでログイン（妻のデバイスは「デバイス共有」機能で追加）
6. Flask サーバーの `HOST` 設定を Tailscale IP に設定
7. スマホのブラウザから `https://[マシン名].tailnet-name.ts.net:5555` でアクセス確認

---

## 17. 制約・前提条件

- 自宅PCは外出中も**電源ON・スリープ無効**にしておく必要がある
- Tailscale の無料プランはデバイス100台まで（本用途では十分）
- MJPEG は H.264 等と比べて帯域効率は劣るが、実装のシンプルさを優先
- Phase 1 の音声はプッシュ・トゥ・トーク方式とし、常時双方向通話はサポートしない
- Phase 2 の「顔を見せる」機能使用中は Talk が常時 ON となるため、ハウリング防止のためリスニング（PC マイク → スマホ）は自動的に無効化される
- Phase 2 の逆方向映像は WebRTC ではなく Socket.IO による JPEG リレー方式を採用。Tailscale VPN 内の通信のため NAT traversal が不要であり、既存アーキテクチャとの一貫性を優先する
- 音声品質は電話相当（16kHz/mono）。高音質ステレオ音声はスコープ外
